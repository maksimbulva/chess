// The source code here is based on the code generated by Yandex.Catboost library
// See https://catboost.ai/docs/concepts/c-plus-plus-api_applycatboostmodel.html

#include "CatboostEvaluator.h"

namespace chesslib {

CatboostEvaluator::CatboostEvaluator(CatboostModel model)
    : binaryFeatures_(model.binaryFeatureCount)
    , model_(model)
{
}

double CatboostEvaluator::applyModel(const std::vector<float>& floatFeatures)
{
    binariseFeatures(floatFeatures);
    return accumulateTreeValues();
}

void CatboostEvaluator::binariseFeatures(const std::vector<float>& floatFeatures)
{
    size_t binFeatureIndex = 0;
    for (size_t i = 0; i < model_.floatFeatureCount; ++i) {
        const float feature = floatFeatures[i];
        const unsigned int borderCount = model_.borderCounts[i];
        for (unsigned int j = 0; j < borderCount; ++j) {
            binaryFeatures_[binFeatureIndex] = static_cast<unsigned char>(feature > model_.borders[binFeatureIndex]);
            ++binFeatureIndex;
        }
    }
}

double CatboostEvaluator::accumulateTreeValues() const
{
    double result = 0.0;
    const unsigned int* treeSplitsPtr = model_.treeSplits.data();
    const double* leafValuesForCurrentTreePtr = model_.leafValues.data();
    for (size_t currentTreeDepth : model_.treeDepth) {
        unsigned int index = 0;
        for (size_t depth = 0; depth < currentTreeDepth; ++depth) {
            index |= (binaryFeatures_[treeSplitsPtr[depth]] << depth);
        }
        result += leafValuesForCurrentTreePtr[index];
        treeSplitsPtr += currentTreeDepth;
        leafValuesForCurrentTreePtr += static_cast<uint32_t>(1 << currentTreeDepth);
    }
    return model_.scale * result + model_.bias;
}

}
